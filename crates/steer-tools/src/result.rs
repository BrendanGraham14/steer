use crate::{
    error::ToolError,
    tools::todo::{TodoItem, TodoWriteFileOperation},
};
use serde::{Deserialize, Serialize};

/// Core enum for all tool results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ToolResult {
    // One variant per built-in tool
    Search(SearchResult),     // grep / astgrep
    FileList(FileListResult), // ls / glob
    FileContent(FileContentResult),
    Edit(EditResult),
    Bash(BashResult),
    Glob(GlobResult),
    TodoRead(TodoListResult),
    TodoWrite(TodoWriteResult),
    Fetch(FetchResult),
    Agent(AgentResult),

    // Unknown or remote (MCP) tool payload
    External(ExternalResult),

    // Failure (any tool)
    Error(ToolError),
}

/// Result for the fetch tool
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FetchResult {
    pub url: String,
    pub content: String,
}

/// Result for the dispatch_agent tool
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentResult {
    pub content: String,
}

/// Result for external/MCP tools
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalResult {
    pub tool_name: String, // name reported by the MCP server
    pub payload: String,   // raw, opaque blob (usually JSON or text)
}

/// Result for grep-like search tools
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchResult {
    pub matches: Vec<SearchMatch>,
    pub total_files_searched: usize,
    pub search_completed: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMatch {
    pub file_path: String,
    pub line_number: usize,
    pub line_content: String,
    pub column_range: Option<(usize, usize)>,
}

/// Result for file listing operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileListResult {
    pub entries: Vec<FileEntry>,
    pub base_path: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileEntry {
    pub path: String,
    pub is_directory: bool,
    pub size: Option<u64>,
    pub permissions: Option<String>,
}

/// Result for file content viewing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileContentResult {
    pub content: String,
    pub file_path: String,
    pub line_count: usize,
    pub truncated: bool,
}

/// Result for edit operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditResult {
    pub file_path: String,
    pub changes_made: usize,
    pub file_created: bool,
    pub old_content: Option<String>,
    pub new_content: Option<String>,
}

/// Result for bash command execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BashResult {
    pub stdout: String,
    pub stderr: String,
    pub exit_code: i32,
    pub command: String,
}

/// Result for glob pattern matching
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GlobResult {
    pub matches: Vec<String>,
    pub pattern: String,
}

/// Result for todo operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TodoListResult {
    pub todos: Vec<TodoItem>,
}
/// Result for todo write operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TodoWriteResult {
    pub todos: Vec<TodoItem>,
    pub operation: TodoWriteFileOperation,
}

// Newtype wrappers to avoid conflicting From impls
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MultiEditResult(pub EditResult);
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplaceResult(pub EditResult);
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AstGrepResult(pub SearchResult);
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GrepResult(pub SearchResult);

// Trait for typed tool outputs
pub trait ToolOutput: Serialize + Send + Sync + 'static {}

// Implement ToolOutput for all result types
impl ToolOutput for SearchResult {}
impl ToolOutput for GrepResult {}
impl ToolOutput for FileListResult {}
impl ToolOutput for FileContentResult {}
impl ToolOutput for EditResult {}
impl ToolOutput for BashResult {}
impl ToolOutput for GlobResult {}
impl ToolOutput for TodoListResult {}
impl ToolOutput for TodoWriteResult {}
impl ToolOutput for MultiEditResult {}
impl ToolOutput for ReplaceResult {}
impl ToolOutput for AstGrepResult {}
impl ToolOutput for ExternalResult {}
impl ToolOutput for FetchResult {}
impl ToolOutput for AgentResult {}
impl ToolOutput for ToolResult {}

// Manual From implementations only for types not generated by the macro
impl From<ExternalResult> for ToolResult {
    fn from(r: ExternalResult) -> Self {
        Self::External(r)
    }
}

impl From<ToolError> for ToolResult {
    fn from(e: ToolError) -> Self {
        Self::Error(e)
    }
}

impl ToolResult {
    /// Format the result for LLM consumption
    pub fn llm_format(&self) -> String {
        match self {
            ToolResult::Search(r) => {
                if r.matches.is_empty() {
                    "No matches found.".to_string()
                } else {
                    let mut output = Vec::new();
                    let mut current_file = "";

                    for match_item in &r.matches {
                        if match_item.file_path != current_file {
                            if !output.is_empty() {
                                output.push("".to_string());
                            }
                            current_file = &match_item.file_path;
                        }
                        output.push(format!(
                            "{}:{}: {}",
                            match_item.file_path, match_item.line_number, match_item.line_content
                        ));
                    }

                    output.join("\n")
                }
            }
            ToolResult::FileList(r) => {
                if r.entries.is_empty() {
                    format!("No entries found in {}", r.base_path)
                } else {
                    let mut lines = Vec::new();
                    for entry in &r.entries {
                        let type_indicator = if entry.is_directory { "/" } else { "" };
                        let size_str = entry.size.map(|s| format!(" ({s})")).unwrap_or_default();
                        lines.push(format!("{}{}{}", entry.path, type_indicator, size_str));
                    }
                    lines.join("\n")
                }
            }
            ToolResult::FileContent(r) => r.content.clone(),
            ToolResult::Edit(r) => {
                if r.file_created {
                    format!("Successfully created {}", r.file_path)
                } else {
                    format!(
                        "Successfully edited {}: {} change(s) made",
                        r.file_path, r.changes_made
                    )
                }
            }
            ToolResult::Bash(r) => {
                let mut output = r.stdout.clone();

                if r.exit_code != 0 {
                    if !output.is_empty() && !output.ends_with('\n') {
                        output.push('\n');
                    }
                    output.push_str(&format!("Exit code: {}", r.exit_code));

                    if !r.stderr.is_empty() {
                        output.push_str(&format!("\nError output:\n{}", r.stderr));
                    }
                } else if !r.stderr.is_empty() {
                    if !output.is_empty() && !output.ends_with('\n') {
                        output.push('\n');
                    }
                    output.push_str(&format!("Error output:\n{}", r.stderr));
                }

                output
            }
            ToolResult::Glob(r) => {
                if r.matches.is_empty() {
                    format!("No files matching pattern: {}", r.pattern)
                } else {
                    r.matches.join("\n")
                }
            }
            ToolResult::TodoRead(r) => {
                if r.todos.is_empty() {
                    "No todos found.".to_string()
                } else {
                    format!(
                        "Remember to continue to update and read from the todo list as you make progress. Here is the current list:\n{}",
                        serde_json::to_string_pretty(&r.todos)
                            .unwrap_or_else(|_| "Failed to format todos".to_string())
                    )
                }
            }
            ToolResult::TodoWrite(r) => {
                format!(
                    "Todos have been {:?} successfully. Ensure that you continue to read and update the todo list as you work on tasks.\n{}",
                    r.operation,
                    serde_json::to_string_pretty(&r.todos)
                        .unwrap_or_else(|_| "Failed to format todos".to_string())
                )
            }
            ToolResult::Fetch(r) => {
                format!("Fetched content from {}:\n{}", r.url, r.content)
            }
            ToolResult::Agent(r) => r.content.clone(),
            ToolResult::External(r) => r.payload.clone(),
            ToolResult::Error(e) => format!("Error: {e}"),
        }
    }

    /// Get the variant name as a string for metadata
    pub fn variant_name(&self) -> &'static str {
        match self {
            ToolResult::Search(_) => "Search",
            ToolResult::FileList(_) => "FileList",
            ToolResult::FileContent(_) => "FileContent",
            ToolResult::Edit(_) => "Edit",
            ToolResult::Bash(_) => "Bash",
            ToolResult::Glob(_) => "Glob",
            ToolResult::TodoRead(_) => "TodoRead",
            ToolResult::TodoWrite(_) => "TodoWrite",
            ToolResult::Fetch(_) => "Fetch",
            ToolResult::Agent(_) => "Agent",
            ToolResult::External(_) => "External",
            ToolResult::Error(_) => "Error",
        }
    }
}
